C51 COMPILER V9.59.0.0   FLASH                                                             10/15/2018 22:09:23 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE FLASH
OBJECT MODULE PLACED IN .\Objects\flash.obj
COMPILER INVOKED BY: E:\Keil\Keil_C51\C51\BIN\C51.EXE user\flash.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\user\Inc) DEBUG OBJ
                    -ECTEXTEND PRINT(.\Listings\flash.lst) OBJECT(.\Objects\flash.obj)

line level    source

   1          #include "STC8.H"
   2          #include "intrins.h"
   3          #include "flash.h"
   4          #include "main.h"
   5          
   6          #define CMD_IDLE    0               //ç©ºé—²æ¨¡å¼
   7          #define CMD_READ    1               //IAPå­—èŠ‚è¯»å‘½ä»¤
   8          #define CMD_PROGRAM 2               //IAPå­—èŠ‚ç¼–ç¨‹å‘½ä»¤
   9          #define CMD_ERASE   3               //IAPæ‰‡åŒºæ“¦é™¤å‘½ä»¤
  10          
  11          #define WT_30M          0x80
  12          #define WT_24M          0x81
  13          #define WT_20M          0x82
  14          #define WT_12M          0x83
  15          #define WT_6M           0x84
  16          #define WT_3M           0x85
  17          #define WT_2M           0x86
  18          #define WT_1M           0x87
  19          
  20          #define ERROR   0
  21          #define OK      1
  22          #define USED_BYTE_QTY_IN_ONE_SECTOR   512  //æ‰‡åŒºå¤§å°
  23          BYTE xdata protect_buffer[USED_BYTE_QTY_IN_ONE_SECTOR];
  24          
  25          void IapIdle()
  26          {
  27   1          IAP_CONTR = 0;                              //å…³é—­IAPåŠŸèƒ½
  28   1          IAP_CMD = CMD_IDLE;                                //æ¸…é™¤å‘½ä»¤å¯„å­˜å™¨
  29   1          IAP_TRIG = 0;                               //æ¸…é™¤è§¦å‘å¯„å­˜å™¨
  30   1          IAP_ADDRH = 0x80;                           //å°†åœ°å€è®¾ç½®åˆ°éIAPåŒºåŸŸ
  31   1          IAP_ADDRL = 0;
  32   1      }
  33          
  34          /*----------------------------
  35          ä»ISP/IAP/EEPROMåŒºåŸŸè¯»å–ä¸€å­—èŠ‚
  36          ----------------------------*/
  37          BYTE IapReadByte(WORD addr)
  38          {
  39   1          BYTE dat;
  40   1      
  41   1          IAP_CONTR = WT_24M;                         //ä½¿èƒ½IAP
  42   1          IAP_CMD = CMD_READ;                                //è®¾ç½®IAPè¯»å‘½ä»¤
  43   1          IAP_ADDRL = addr;                           //è®¾ç½®IAPä½åœ°å€
  44   1          IAP_ADDRH = addr >> 8;                      //è®¾ç½®IAPé«˜åœ°å€
  45   1          IAP_TRIG = 0x5a;                            //å†™è§¦å‘å‘½ä»¤(0x5a)
  46   1          IAP_TRIG = 0xa5;                            //å†™è§¦å‘å‘½ä»¤(0xa5)
  47   1          _nop_();
  48   1          dat = IAP_DATA;                             //è¯»IAPæ•°æ®
  49   1          IapIdle();                                  //å…³é—­IAPåŠŸèƒ½
  50   1      
  51   1          return dat;
  52   1      }
  53          
  54          /*----------------------------
C51 COMPILER V9.59.0.0   FLASH                                                             10/15/2018 22:09:23 PAGE 2   

  55          å†™ä¸€å­—èŠ‚æ•°æ®åˆ°ISP/IAP/EEPROMåŒºåŸŸ
  56          ----------------------------*/
  57          void IapProgramByte(WORD addr, BYTE dat)
  58          {
  59   1          IAP_CONTR = WT_24M;                         //ä½¿èƒ½IAP
  60   1          IAP_CMD = CMD_PROGRAM;                                //è®¾ç½®IAPå†™å‘½ä»¤
  61   1          IAP_ADDRL = addr;                           //è®¾ç½®IAPä½åœ°å€
  62   1          IAP_ADDRH = addr >> 8;                      //è®¾ç½®IAPé«˜åœ°å€
  63   1          IAP_DATA = dat;                             //å†™IAPæ•°æ®
  64   1          IAP_TRIG = 0x5a;                            //å†™è§¦å‘å‘½ä»¤(0x5a)
  65   1          IAP_TRIG = 0xa5;                            //å†™è§¦å‘å‘½ä»¤(0xa5)
  66   1          _nop_();
  67   1          IapIdle();                                  //å…³é—­IAPåŠŸèƒ½
  68   1      }
  69          
  70          /*----------------------------
  71          æ‰‡åŒºæ“¦é™¤ 512å­—èŠ‚ä¸€ä¸ªæ‰‡åŒº
  72          ----------------------------*/
  73          void IapEraseSector(WORD addr)
  74          {
  75   1          IAP_CONTR = WT_24M;                         //ä½¿èƒ½IAP
  76   1          IAP_CMD = CMD_ERASE;                                //è®¾ç½®IAPæ“¦é™¤å‘½ä»¤
  77   1          IAP_ADDRL = addr;                           //è®¾ç½®IAPä½åœ°å€
  78   1          IAP_ADDRH = addr >> 8;                      //è®¾ç½®IAPé«˜åœ°å€
  79   1          IAP_TRIG = 0x5a;                            //å†™è§¦å‘å‘½ä»¤(0x5a)
  80   1          IAP_TRIG = 0xa5;                            //å†™è§¦å‘å‘½ä»¤(0xa5)
  81   1          _nop_();                                    //
  82   1          IapIdle();                                  //å…³é—­IAPåŠŸèƒ½
  83   1      }
  84          
  85          
  86          /* å†™æ•°æ®è¿› æ•°æ®Flashå­˜å‚¨å™¨, åªåœ¨åŒä¸€ä¸ªæ‰‡åŒºå†…å†™ï¼Œä¸ä¿ç•™åŸæœ‰æ•°æ® */
  87          /* begin_addr,è¢«å†™æ•°æ®Flashå¼€å§‹åœ°å€ï¼›counter,è¿ç»­å†™å¤šå°‘ä¸ªå­—èŠ‚ï¼› array[]ï¼Œæ•°æ®æ¥æº  
             - */
  88          //BYTE sequential_write_flash_in_one_sector(WORD begin_addr, WORD counter, BYTE array[])
  89          //{
  90          //    WORD i = 0;
  91          //    WORD in_sector_begin_addr = 0;
  92          //    WORD sector_addr = 0;
  93          
  94          //    /* åˆ¤æ˜¯å¦æ˜¯æœ‰æ•ˆèŒƒå›´,æ­¤å‡½æ•°ä¸å…è®¸è·¨æ‰‡åŒºæ“ä½œ */
  95          //    if(counter > USED_BYTE_QTY_IN_ONE_SECTOR)
  96          //        return  ERROR;
  97          //    in_sector_begin_addr = begin_addr & 0x01ff;
  98          //    if((in_sector_begin_addr + counter) > USED_BYTE_QTY_IN_ONE_SECTOR)
  99          //        return ERROR;
 100          
 101          //    /* æ“¦é™¤ è¦ä¿®æ”¹/å†™å…¥ çš„æ‰‡åŒº */
 102          //    IapEraseSector(begin_addr);
 103          
 104          //    for(i=0; i<counter; i++)
 105          //    {
 106          //        /* å†™ä¸€ä¸ªå­—èŠ‚ */
 107          //        IapProgramByte(begin_addr, array[i]);
 108          //        /*  æ¯”è¾ƒå¯¹é”™ */
 109          //        if (SendData(IapReadByte(begin_addr)) != array[i])
 110          //        {
 111          //            IapIdle();
 112          //            return ERROR;
 113          //        }
 114          //        begin_addr++;
 115          //    }
C51 COMPILER V9.59.0.0   FLASH                                                             10/15/2018 22:09:23 PAGE 3   

 116          //    IapIdle();
 117          //    return  OK;
 118          //}
 119          
 120          /* å†™æ•°æ®è¿›æ•°æ®Flashå­˜å‚¨å™¨(EEPROM), åªåœ¨åŒä¸€ä¸ªæ‰‡åŒºå†…å†™ï¼Œä¿ç•™åŒä¸€æ‰‡åŒºä¸­ä¸éœ€ä¿®æ
             -”¹çš„æ•°æ®    */
 121          /* begin_addr,è¢«å†™æ•°æ®Flashå¼€å§‹åœ°å€ï¼›counter,è¿ç»­å†™å¤šå°‘ä¸ªå­—èŠ‚ï¼› array[]ï¼Œæ•°æ®æ¥æº  
             -     */
 122          BYTE write_flash_pr(WORD begin_addr, WORD counter, BYTE* array)
 123          {
 124   1          WORD i = 0;
 125   1          WORD in_sector_begin_addr = 0;
 126   1          WORD sector_addr = 0;
 127   1          WORD byte_addr = 0;
 128   1          /* åˆ¤æ˜¯å¦æ˜¯æœ‰æ•ˆèŒƒå›´,æ­¤å‡½æ•°ä¸å…è®¸è·¨æ‰‡åŒºæ“ä½œ */
 129   1          if(counter > USED_BYTE_QTY_IN_ONE_SECTOR)
 130   1              return ERROR;
 131   1          in_sector_begin_addr = begin_addr & 0x01ff;
 132   1          /* å‡å®šä»æ‰‡åŒºçš„ç¬¬0ä¸ªå­—èŠ‚å¼€å§‹ï¼Œåˆ°USED_BYTE_QTY_IN_ONE_SECTOR-1ä¸ªå­—èŠ‚ç»“æŸ,åé¢éƒ¨åˆ
             -†ä¸ç”¨,ç¨‹åºæ˜“ç¼–å†™ */
 133   1          if((in_sector_begin_addr + counter) > USED_BYTE_QTY_IN_ONE_SECTOR)
 134   1              return ERROR;
 135   1      
 136   1          /* å°†è¯¥æ‰‡åŒºæ•°æ® 0 - (USED_BYTE_QTY_IN_ONE_SECTOR-1) å­—èŠ‚æ•°æ®è¯»å…¥ç¼“å†²åŒºä¿æŠ¤ */
 137   1          sector_addr = (begin_addr & 0xfe00);
 138   1          byte_addr = sector_addr;
 139   1      
 140   1          //è¯»å–æ•´é¡µæ•°æ®
 141   1          for(i = 0; i < USED_BYTE_QTY_IN_ONE_SECTOR; i++)
 142   1          {
 143   2              protect_buffer[i] = IapReadByte(byte_addr++);
 144   2          }
 145   1      
 146   1          /* å°†è¦å†™å…¥çš„æ•°æ®å†™å…¥ä¿æŠ¤ç¼“å†²åŒºçš„ç›¸åº”åŒºåŸŸ,å…¶ä½™éƒ¨åˆ†ä¿ç•™ */
 147   1          for(i = 0; i < counter; i++)
 148   1          {
 149   2              protect_buffer[in_sector_begin_addr++] = array[i];
 150   2          }
 151   1          
 152   1      //    for(i = 0; i < USED_BYTE_QTY_IN_ONE_SECTOR; i++)
 153   1      //    {
 154   1      //        UartSend(protect_buffer[i]);
 155   1      //    }
 156   1          /* æ“¦é™¤ è¦ä¿®æ”¹/å†™å…¥ çš„æ‰‡åŒº */
 157   1          IapEraseSector(sector_addr);
 158   1      
 159   1          /* å°†ä¿æŠ¤ç¼“å†²åŒºçš„æ•°æ®å†™å…¥ Data Flash, EEPROM */
 160   1          byte_addr = sector_addr;
 161   1          for(i = 0; i< USED_BYTE_QTY_IN_ONE_SECTOR; i++)
 162   1          {
 163   2              /* å†™ä¸€ä¸ªå­—èŠ‚ */
 164   2              IapProgramByte(byte_addr + i, protect_buffer[i]);
 165   2              /*  æ¯”è¾ƒå¯¹é”™ */
 166   2              if (IapReadByte(byte_addr + i) != protect_buffer[i])
 167   2              {
 168   3                  IapIdle();
 169   3                  return ERROR;
 170   3              }
 171   2      //        byte_addr++;
 172   2          }
 173   1          IapIdle();
 174   1          return OK;
C51 COMPILER V9.59.0.0   FLASH                                                             10/15/2018 22:09:23 PAGE 4   

 175   1      }
 176          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    374    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    512    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
